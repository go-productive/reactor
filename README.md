# 基于linux epoll实现的reactor网络线程模型

- 先搜下reactor网络线程模型的概念，弄懂了再使用
- 使用原生go系统调用函数实现，多路复用io
- 对比go官方网络io在百万tcp连接时能减少很多内存的使用，一条tcp一个goroutine吃内存
- 仅在单机支持百万tcp连接时使用，连接数少时拉不开差距，反而go官方网络阻塞式io写逻辑容易

[example](example/server.go)

# 注意

- 只支持在linux上使用，不整各系统兼容那些花里胡哨的，这样反而更简单
- io线程尽量不要执行阻塞的代码，最好的实践是io线程解码拿到结构体后再异步交给业务线程处理，业务线程处理完后再调用异步写io方法
- io线程解码拿到结构体能减少内存的copy，因为每个tcp连接都有自己的buf。如果不这样，读io时会覆盖buf导致业务线程必须copy出来
- 业务线程可采用goroutine池优化，业务线程还可以保证每条tcp连接上的消息线性处理，这样不用考虑并发问题
- 代码写的很简单，想学epoll的或者想用的更好的完全可以fork出来
